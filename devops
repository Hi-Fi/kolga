#!/usr/bin/env python3

import argparse
from typing import List

from scripts.settings import settings


class Devops:
    def __init__(self) -> None:
        self.parser = argparse.ArgumentParser(description="Anders Devops")
        subparsers = self.parser.add_subparsers(
            dest="command", metavar="<command>", required=True
        )

        subparsers.add_parser(
            "create_images", help="Builds Docker images from a local Dockerfile"
        )

        deploy_application_parser = subparsers.add_parser(
            "deploy_application",
            help="Deploy an application based on the current Docker image",
        )
        deploy_application_parser.add_argument(
            "-t", "--track", dest="track", default=settings.DEFAULT_TRACK
        )

        deploy_service_parser = subparsers.add_parser(
            "deploy_service", help="Deploy a service supported by the devops pipeline"
        )
        deploy_service_parser.add_argument(
            "-t", "--track", dest="track", default=settings.DEFAULT_TRACK
        )
        deploy_service_parser.add_argument("-s", "--service", dest="service")
        deploy_service_parser.add_argument("-e", "--env-var", dest="envvar")
        deploy_service_parser.add_argument(
            "-p", "--projects", dest="projects", nargs="+"
        )

        subparsers.add_parser("docker_test_image", help="Print image tag")

        subparsers.add_parser("help", help="Prints this help message")

        subparsers.add_parser("logo", help="Prints the magnificent Anders DevOps logo")

        review_cleanup_parser = subparsers.add_parser(
            "review_cleanup", help="Cleans up the current namespace"
        )
        review_cleanup_parser.add_argument(
            "-t", "--track", dest="track", default=settings.DEFAULT_TRACK
        )

        subparsers.add_parser(
            "test_setup",
            help="Sets up an environment for running tests on built Docker image",
        )

    def run_command(self) -> None:
        args = vars(self.parser.parse_args())
        command = args.pop("command")

        # use dispatch pattern to invoke method with same name
        getattr(self, command)(**args)

    def create_images(self) -> None:
        from scripts.libs.git import Git
        from scripts.libs.docker import Docker
        from scripts.libs.project import Project
        from scripts.utils.general import (
            BUILT_DOCKER_TEST_IMAGE,
            create_artifact_file_from_dict,
            env_var_safe_key,
        )

        g = Git()
        g.update_submodules()

        d = Docker()
        d.login()
        images = d.build_stages()
        d.push_images(images)

        project = Project(track="development")
        artifact_data = {
            f"{env_var_safe_key(project.name)}_{BUILT_DOCKER_TEST_IMAGE}": d.test_image_tag()
        }

        create_artifact_file_from_dict(
            env_dir=settings.BUILD_ARTIFACT_FOLDER,
            data=artifact_data,
            filename="docker_build",
        )

    def deploy_application(self, track: str) -> None:
        from scripts.libs.kubernetes import Kubernetes
        from scripts.libs.project import Project

        main_project = Project(track=track)
        projects = main_project.dependency_projects + [main_project]

        k = Kubernetes(track=track)
        k.setup_helm()
        namespace = k.create_namespace()

        for project in projects:
            file_secret_name, file_secrets_paths = k.create_file_secrets_from_environment(
                namespace=namespace, track=track,
            )
            secret_data = dict(project.secret_data.items() + file_secrets_paths.items())  # type: ignore
            k.create_secret(
                data=secret_data,
                namespace=namespace,
                track=track,
                secret_name=project.secret_name,
                project=project,
            )
            # TODO: Move this to the Project class
            k.create_basic_auth_secret(
                namespace=namespace, track=track, project=project
            )
            k.create_application_deployment(
                namespace=namespace, track=track, project=project
            )

    def deploy_service(
        self, track: str, service: str, envvar: str, projects: List[str]
    ) -> None:
        from scripts.libs.kubernetes import Kubernetes
        from scripts.libs.service import Service
        from scripts.libs.services import services
        from scripts.utils.general import create_artifact_file_from_dict

        service_class = services.get(service, None)
        if not service_class:
            raise Exception(f"The service {service} is currently not supported")

        k = Kubernetes(track=track)
        k.setup_helm()
        namespace = k.create_namespace()

        service_instance = service_class(
            name=service, track=track, artifact_name=envvar
        )

        for project in projects:
            project_service = Service(
                name=project, track=track, chart_path=k.get_helm_path()
            )
            service_instance.add_prerequisite(project_service)

        service_instance.setup_prerequisites()
        k.deploy_service(service=service_instance, track=track, namespace=namespace)
        create_artifact_file_from_dict(
            env_dir=settings.SERVICE_ARTIFACT_FOLDER,
            data=service_instance.get_artifacts(),
            filename=service,
        )

    def help(self) -> None:
        self.parser.print_help()

    def review_cleanup(self, track: str) -> None:
        from scripts.libs.kubernetes import Kubernetes

        k = Kubernetes(track=track)
        k.delete_namespace()

    def test_setup(self) -> None:
        from scripts.libs.docker import Docker
        from scripts.libs.git import Git

        g = Git()
        g.update_submodules()

        d = Docker()
        d.login()

        test_image = settings.BUILT_DOCKER_TEST_IMAGE
        if not test_image:
            raise ValueError(f"No test image {test_image} found")
        d.pull_image(test_image)

    def docker_test_image(self) -> None:
        from scripts.libs.docker import Docker

        d = Docker()
        print(d.test_image_tag())  # noqa: T001

    def logo(self) -> None:
        logo = """
      ___            _                ______           _____
     / _ \\          | |               |  _  \\         |  _  |
    / /_\\ \\_ __   __| | ___ _ __ ___  | | | |_____   _| | | |_ __  ___
    |  _  | '_ \\ / _` |/ _ \\ '__/ __| | | | / _ \\ \\ / / | | | '_ \\/ __|
    | | | | | | | (_| |  __/ |  \\__ \\ | |/ /  __/\\ V /\\ \\_/ / |_) \\__ \\
    \\_| |_/_| |_|\\__,_|\\___|_|  |___/ |___/ \\___| \\_/  \\___/| .__/|___/
                                                            | |
                                                            |_|
        """  # noqa: W291
        print(logo)  # noqa: T001


if __name__ == "__main__":
    do = Devops()
    do.run_command()
